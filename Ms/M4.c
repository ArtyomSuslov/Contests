#include <unistd.h>
#include <signal.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
    Задача: 
        Получить ооогромное число и уменьшить его до 0.
        Чтобы число было ооогромным оно представлено в виде строки.
        Чтобы уменьшить число на 1 используется функция dec, 
        ее реализация в ejudge.
        А также нужно каждые 5 секунд 
        выводить результат вычислений.
        Кроме того, по сигналу SIGINT 
        нужно распечатать кол-во секунд до вывода значения.

    Реализация:
        Для просмотра промежуточных значений числа 
        используется SIGALRM
        Процесс получает его каждые 5 секунд 
        (он вызывается рекурсивно см. sig_alrm).

        Чтобы посмотреть сколько времени осталось 
        до вывода промежуточного значения,
        установлен обработчик для сигнала SIGINT.
        Обработчик сбрасывает текущий вызов alarm, вызывая alarm(0)
        и печатает значение alarm(0), 
        т.е. сколько оставалось времени до "нового" SIGALRM.
        После этого перезапускает "рекурсию", 
        вызывая alarm от того числа, которое распечатали.
        На самом деле это немного тормозит 
        вывод промежуточных значений:
            Все округляется до секунд. 
            К примеру, получив SIGINT 
            за 1.0001 секунду до нового SIGALRM, 
            процесс получит новый SIGALRM после 2 секунд,
            потому что округление идет в большую сторону 
            (см. реализацию alarm)
            Но на самом деле даже больше, 
            так как нужно отработать системному вызову alarm(0), 
            а потом системному вызову alarm от 
            полученного alarm(0) числа.

    Проблемы и её решение:
            Так как число может быть большим, 
            то во время выполнения dec может прийти SIGALRM.
            Что тогда?
                1.1) Пропустить этот сигнал 
                (не подходит под условие задачи)
                1.2) Распечатать число в процессе преобразования 
                (плохое решение)
                1.3) Подождать немного, потом распечатать 
                (непонятно сколько ждать, 
                т.к. неизвестна реализация dec, размер числа)
                1.4) Распечатать число сразу после 
                завершения преобразования

            Я выбрал вариант 1.4 как самый надежный и правильный.

            Чтобы реализовать 1.4 пришлось использовать 
            две глобальных переменных is_calc, need_print.

            В то время как происходят вычисления is_calc == 1 (см. main)
            Если в это время приходит сигнал SIGALRM, 
            то он проверяет этот флаг.

            В обработчике SIGALRM:
            Если is_calc == 1, то значит печатать число нельзя, 
                делаем need_print = 1.
                После выхода из обработчика сигнала, 
                завершается выполнение dec, 
                возвращаемся в main, там проверяем значение need_print.
                Если need_print == 1, то печатаем число и опускаем флаг, 
                иначе идем на следующую итерацию.
            Если is_calc == 0, то значит число обработано 
            и можно печатать, печатаем.

            P.S.
            Это решение верно, если функция dec отрабатывает 
            не более чем 5 секунд, иначе
            два сигнала SIGALRM поднимут флаг need_print дважды, 
            но распечатается число лишь один раз, вместо двух. 
*/


enum { SEC_TO_ALARM = 5 };

char *num;

int is_calc = 0;
int need_print = 0;

/*
char *
dec (char *num) {
    size_t length = strlen(num);
    int need_dec = 1;
    for (size_t i = length - 1;; --i) {
        if (!need_dec) {
            break;
        }
        if (num[i] == '0') {
            num[i] = '9';
        } else {
            need_dec = 0;
            num[i] -= 1;
        }
    }
    char *ptr;
    for (ptr = num; *ptr == '0'; ptr++);
    if (*ptr == 0) {
        ptr--;
    }
    return ptr;
}
*/

void
sig_alrm (int sig) {
    if (!is_calc) {
        //printf("%s\n", num); Why doesn`t printf work?
        write(1, num, strlen(num));
        printf("\n");
    } else {
        need_print = 1;
    }
    alarm(SEC_TO_ALARM);
}

void
sig_int (int sig) {
    unsigned int to_alarm = alarm(0);
    alarm(to_alarm);
    printf("%d\n", to_alarm);
}


int
main (int argc, char **argv) {
    num = argv[1];

    signal(SIGALRM, sig_alrm);
    signal(SIGINT, sig_int);

    alarm(SEC_TO_ALARM);

    while (*num != '0') {
        is_calc = 1;
        num = dec(num);
        is_calc = 0;

        if (need_print == 1) {
            write(1, num, strlen(num));
            printf("\n");
            need_print = 0;
        }

    }

    return 0;
}